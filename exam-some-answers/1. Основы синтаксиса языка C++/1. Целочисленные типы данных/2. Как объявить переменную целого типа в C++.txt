* какие способы проинициализировать переменную?
-----------------------------------------------
<тип> <идентификатор> <инициализация>;
int x;      <- без инициализации, плохо, будет ошибка "использована неиницианализированная
							локальная переменная"
int x = 1; 			// будет инициализировано в 1
int x(1); 			// будет инициализировано в 1
int x{1}; 			// будет инициализировано в 1
int x{}; 			// будет инициализировано в 0
int x = 3 + 4 + 5 + 6 + 7;	// можно присвоить выражение, тут = 25
int x = (2 + 1) * 8 / 2;	// = 3 * 8 / 2 = 24 / 2 = 12
signed x = -1; 			// int
unsigned x = 1; 		// unsigned int
long int x = 200; 		// int
unsigned long x = 2000;		// unsigned long
unsigned long int x = 200; 	// unsigned long
auto x = 1; 			// автовывод типа, будет int-переменная со значением 1
auto x = 3'000'000'000; 	// будет unsigned int (но у меня __int64, типа long long, компилятор такой)
auto x = 3'000'000'000u; 	// а это уже unsigned int 100%

алгоритм вывода auto:
1. проверяет n < INT_MAX? если да, то пихает в int
2. если не влез в int, пробует запихнуть в unsigned int
3. если не влез в unsigned int, пихает в long long
4. если не влез в long long, то пихает в unsigned long long
5. не влез в ULL -> ошибка "слишком большая целочисленная константа"

числовые литералы:
------ ДЕСЯТИЧНЫЕ:
auto x = 12345		// int автоматически
auto x = 99999L		// long, суффикс (литерал) L, l
auto x = 99983UL	// unsigned long, литерал UL, ul
можно группировать разряды (для большей читаемости):
int x = 2'000'000'000;
------ ШЕСТНАДЦАТЕРИЧНЫЕ (префикс 0x - hexadecimal):
auto x = 0xFFFFFF;	// int, входит в диапазон
auto d = 0xFeedBeef;	// unsigned int, превышает INT_MAX
auto j = 0x32aab1d;	// int
------ ДВОИЧНЫЕ (префикс 0b - binary):
auto 0b01; 		// 1, int
------ ВОСЬМЕРИЧНЫЕ (префикс 0): // в ней удобно записывать права доступа к файлам
auto 003;
auto 0723; // = 3 + 2 * 8 + 7 * 64 = ...

узнать тип auto можно так:
std::cout << typeid(<индентификатор>).name() << "\n";


* можно ли unsigned int x присвоить отрицательное число?
--------------------------------------------------------
да, можно, но это приведет к зацикливанию. например:
unsigned int x = -1;
если вывести x, он будет = 4294967295   (0xFFFFFFFF)
константа максимального значения этого типа UINT32_MAX тоже = 4294967295


* для чего ключевое слово signed? чем signed int отличается от просто int?
signed - явное указание знаковости переменной. практически ничем не отличается, за
исключением для типа char, например:
char x = 'A'; <- может быть signed или unsigned в зависимости от компилятора
