float f = 3.14;
double d = 3.1415;
double d = 3.1415f;	// так тоже можно, будет тип double
auto x = 21.5; 		// будет тип double, он по умолчанию для вещественных
auto x = 21.5f; 	// будет тип float
auto x = 21.5L;		// будет тип long double

иногда числа настолько большие, что не хотелось бы, например, писать 15 нулей. для 
этого есть ЭКСПОНЕНЦИАЛЬНАЯ ФОРМА ЗАПИСИ:
auto x = 2e+10f; 	// пишется буква e, потом напишется, на 10 в какой степени нужно умножить, float
auto x = -3.835e-6; 	// - 3.835 * (10^-6), и это всё имеет тип long double
например ноль:
double eps = 1e-10;

можно ещё выражние, но тут есть ньюанс:
float n = 8 / 3;	// выведет 2.0, т.к внутри выражения целый тип, (int)8 / (int)3 = 2, остаток 2 отбрасывается
			// и потом результат этого выражения приводится к float, 2 -> 2.0
			// будет сообщение "результат целочисленного деления усекается перед приведением к значению с
			// плавающей запятой

//float n = 8f / 3f;	// так нельзя, определенный пользователем литерал не найден
float n = 8.0 / 3.0;	// вот так правильно
float n = 8.0f / 3.0f;	// так тоже можно